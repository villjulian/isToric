# isToric

This repo contains a SAGE implementation for the algorithm presented in [this paper](https://arxiv.org/abs/2408.14323).
Everything is contained in the file isToric.sage, the other files contain examples.
In the case of .sage files they can be loaded or copied into a SAGE session.
Part of this code is based on code from [this paper](https://arxiv.org/abs/2309.10741).


The purpose of the algorithm is to decide if a given variety can be made toric by a linear change of coordinates.
This means, given an ideal I, does there exist a linear coordinate change such that in the new coordinates the ideal is generated by unital binomials and is prime.

# Documentation

```LieAlgebra(ideal I)```

This is our main $\texttt{class}$. Let $G$ be the subgroup of $GL_n(\mathbb{C})$ that maps $I$ to itself. This class is used to compute a basis of the Lie algebra of the Lie group $G$.
We can also construct it by giving it a generating set directly and instead of an ideal the parameter \texttt{None}. 
Note that the vector space generated by the given matrices has to generate a Lie algebra, i.e. being closed under taking commutators.

The main functions of this class are as follows.

```dimension()```

Returns the dimension of the Lie algebra.

```basis()```

Returns a basis of the Lie algebra.

```part_random_element()```

Tries to pick a random linear combination of the basis elements with coefficients $\pm\frac{1}{2},\pm 1,\pm 2,0$ until this matrix has unique eigenvalues. 
If this does not happen after several attempts, a more random element is returned allowing more coefficients.


```cartan_algebra(matrix A)```

Computes $c := ker\ ad(A)^{dim (\texttt{self})}$ where $ad(A)$ is the endomorphism on the Lie algebra mapping $B$ to $AB-BA$. 
This is always a Lie subalgebra and is returned if it is a Cartan subalgebra of the Lie algebra. Otherwise the output is $\texttt{False}$.

```random_cartan_algebra()```

Picks a random element in the Lie algebra and computes the corresponding Cartan algebra.

```find_torus()```

Decomposes every basis element of the Lie algebra into its diagonalizable and nilpotent part and returns an element of class $\texttt{LieAlgebra}$ generated by all diagonalizable elements.
This is only supposed to be used when $\texttt{self}$ is a Cartan algebra. In this case the returned element is a toral Lie algebra corresponding to the unique maximal torus inside $\texttt{self}$.

```random_torus()```

Computes a random Cartan algebra and inside it, its unique maximal toral subalgebra. This is a maximal toral subalgebra of $\texttt{self}$.

```sim_diagonalize()```

Should only be used when $\texttt{self}$ is a toral algebra. Computes a base change $S$ over the ring of algebraic numbers that simultaneously diagonalizes the basis of $\texttt{self}$.


Next, we provide functions to handle our ideal or to use when doing parts by hand.


```matrix_diagonalize(matrix A)```

Returns an invertible matrix $S$ over the field of algebraic numbers diagonalizing $A$, i.e. such that $S^{-1}AS$ is diagonal.

```ideal_diagonalize(ideal I, matrix S)```

Applies the coordinate change given by the rows of $S$ to the ideal $I$.
Outputs the resulting ideal in the polynomial ring over the field of algebraic numbers.

```is_binomial(ideal I)```

Tests if the ideal $I$ can be generated by binomials (polynomials with at most two terms, we do not require the coefficients to be 0,1) and returns $\texttt{True}$ or $\texttt{False}$. 
Also returns a reduced Gröbner basis of $I$.

```binomial_ideal_is_prime(list gb)```

Checks if the binomial ideal generated by the Gröbner basis given in gb is prime over $\mathbb{C}$.


```ideal_is_toric(ideal I)```

Decides if the ideal $I$ is toric after some linear coordinate change. If this is the case the output is $\texttt{True}$ and a matrix $S\in GL_n(\overline{\mathbb{Q}})$ is returned turning $I$ into a binomial ideal. Otherwise the output is $\texttt{False}$.

  ## Example 1
  
  Consider the ideal $I$ generated by the three forms $p_1,p_2,p_3\in\mathbb{C}[q,w,e,r,t,y,u,o]_2$
  forming a complete intersection,
  $$p_1=e t - r y - q u + w o,\quad p_2=w t - q y - r u + e o,\quad p_3=w e - q r - y u + t o. $$
  We present the SAGE code to find a coordinate change making this ideal binomial.
  


```
load('.../isToric.sage')
R.<q,w,e,r,t,y,u,o>=PolynomialRing(QQ)
p1 = e*t-r*y-q*u+w*o
p2 = w*t-q*y-r*u+e*o
p3 = w*e-q*r-y*u+t*o
I = ideal(p1,p2,p3)
```
Compute the Lie algebra and a random Cartan algebra of L.
```
lie = LieAlgebra(I)
c = lie.random_cartan_algebra()
```
Compute the unique toral Lie algebra inside c.
```
t = c.find_torus()
```
Diagonalizing a generic element in t gives a coordinate change that simultaneously diagonalizes t.
```
S = t.sim_diagonalize()
```

We apply our coordinate change to our starting ideal.
```
J = ideal_diagonalize(I,S)
```

We check if after the coordinate change the ideal is binomial and prime.
```
[is_bin,gb] = is_binomial(J)
print(is_bin) #returns True
binomial_ideal_is_prime(gb) #returns True
```
Or as a short version of the above we can also use
 
```
ideal_is_toric(I)
```

For a non-homogenous ideal the workflow is exactly the same. We just note that the affine-linear(!!!) coordinate change we get is a $(n+1) \times (n+1)$-matrix 
where the first row and column correspond to the homogenizing variable. Moreover, by construction, the first row is the first unit vector.

  ## Example 2

Using Proposition 4.13. in the paper it suffices to compute the dimension of a maximal torus if we know that the homogeneous ideal is prime and it does not contain a linear form.

Assume $I$ is a homogeneous prime ideal containing no linear form and the dimension of the quotient ring is $s$.
If the dimension
```
lie = LieAlgebra(I)
lie.random_torus().dimension()
```
is strictly less than $s$, then $I$ cannot be made toric. If the dimension is equal to $s$ then this is possible.
The downside is that one needs to be able to compute the dimension of the ideal and hence a Gröbner basis.
The upside is that since no diagonalization is needed, there are no computations using algebraic numbers which may not terminate in a reasonable amount of time.

