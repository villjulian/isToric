# isToric

This repo contains a SAGE implementation for the algorithm presented in .....
Everything is contained in the file isToric.sage, the other files contain examples.
In the case of .sage files they can be loaded or copied into a SAGE session and the
.ipynb files are to be used in a Jupyter notebook.


The purpose of the algorithm is to decide if a given variety can be made toric by a linear change of coordinates.

**Maybe abstract of paper here??**

# Documentation

LieAlgebra(ideal I)

This is our main $\texttt{class}$. Let $G$ be the subgroup of $GL_n(\mathbb{C})$ that maps $I$ to itself. This class is used to compute a basis of the Lie algebra of the Lie group $G$.
We can also construct it by giving it a generating set directly and instead of an ideal the parameter \texttt{None}. 
Note that the vector space generated by the given matrices has to generate a Lie algebra, i.e. being closed under taking commutators.

The main functions of this class are as follows.

dimension()

Returns the dimension of the Lie algebra.

basis()

Returns a basis of the Lie algebra.

part_random_element()

Tries to pick a random linear combination of the basis elements with coefficients $\pm\frac{1}{2},\pm 1,\pm 2,0$ until this matrix has unique eigenvalues. 
If this does not happen after several attempts, a more random element is returned allowing more coefficients.


cartan_algebra(matrix A)

Computes $c := ker\ ad(A)^{dim (\texttt{self})}$ where $ad(A)$ is the endomorphism on the Lie algebra mapping $B$ to $AB-BA$. 
This is always a Lie subalgebra and is returned if it is a Cartan subalgebra of the Lie algebra. Otherwise the output is $\texttt{False}$.

random_cartan_algebra()

Picks a random element in the Lie algebra and computes the corresponding Cartan algebra.

find_torus()

Decomposes every basis element of the Lie algebra into its diagonalizable and nilpotent part and returns an element of class $\texttt{LieAlgebra}$ generated by all diagonalizable elements.
This is only supposed to be used when $\texttt{self}$ is a Cartan algebra. In this case the returned element is a toral Lie algebra corresponding to the unique maximal torus inside $\texttt{self}$.

random_torus()

Computes a random Cartan algebra and inside it, its unique maximal toral subalgebra. This is a maximal toral subalgebra of $\texttt{self}$.

sim_diagonalize()

Should only be used when $\texttt{self}$ is a toral algebra. Computes a base change $S$ over the ring of algebraic numbers that simultaneously diagonalizes the basis of $\texttt{self}$.


Next, we provide functions to handle our ideal or to use when doing parts by hand.


matrix_diagonalize(matrix A)

Returns an invertible matrix $S$ over the field of algebraic numbers diagonalizing $A$, i.e. such that $S^{-1}AS$ is diagonal.

ideal_diagonalize(ideal I, matrix S)

Applies the coordinate change given by the rows of $S$ to the ideal $I$.
Outputs the resulting ideal in the polynomial ring over the field of algebraic numbers.

is_binomial(ideal I)

Tests if the ideal $I$ can be generated by binomials (polynomials with at most two terms, we do not require the coefficients to be 0,1) and returns $\texttt{True}$ or $\texttt{False}$. 
Also returns a reduced Gröbner basis of $I$.

binomial_ideal_is_prime(list gb)

Checks if the binomial ideal generated by the Gröbner basis given in gb is prime over $\mathbb{C}$.


ideal_is_toric(ideal I)

Decides if the ideal $I$ is toric after some linear coordinate change. If this is the case the output is $\texttt{True}$ and a matrix $S\in GL_n(\overline{\mathbb{Q}})$ is returned turning $I$ into a binomial ideal. Otherwise the output is $\texttt{False}$.

  ## Example
  
  Consider the ideal $I$ generated by the three forms $p_1,p_2,p_3\in\mathbb{C}[q,w,e,r,t,y,u,o]_2$
  forming a complete intersection,
  $$p_1=e t - r y - q u + w o,\quad p_2=w t - q y - r u + e o,\quad p_3=w e - q r - y u + t o. $$
  We present the SAGE code to find a coordinate change making this ideal binomial.
  


```
load('.../isToric.sage')
R.<q,w,e,r,t,y,u,o>=PolynomialRing(QQ)
p1=e*t-r*y-q*u+w*o
p2=w*t-q*y-r*u+e*o
p3=w*e-q*r-y*u+t*o
I=ideal(p1,p2,p3)
```
Compute the Lie algebra and a random Cartan algebra of L.
```
lie = LieAlgebra(I)
c = lie.random_cartan_algebra()
```
Compute the unique toral Lie algebra inside c.
```
t = c.find_torus()
```
Diagonalizing a generic element in t gives a coordinate change that simultaneously diagonalizes t.
```
S = t.sim_diagonalize()
```

We apply our coordinate change to our starting ideal.
```
J = ideal_diagonalize(I,S)
```

We check if after the coordinate change the ideal is binomial and prime.
```
[is_bin,gb] = is_binomial(J)
print(is_bin) #returns True
binomial_ideal_is_prime(gb) #return True
```
Or as a short version of the above we can also use
 
```
ideal_is_toric(I)
```



For a non-homogenous ideal the workflow is exactly the same. We just note that the affine-linear(!!!) coordinate change we get is a $(n+1) \times (n+1)$-matrix 
where the first row and column correspond to the homogenizing variable. Moreover, by construction, the first row is the first unit vector. 
For example the inverse of the matrix
$$\begin{array}{ccc}
x_{11} & x_{12} & x_{13}\\
x_{21} & x_{22} & x_{23}
\end{array}$$

applied to a polynomial in $\mathbb{C}[x,y]$ corresponds to the variable substitution $x\mapsto 1+2x+3y,\, y\mapsto 2+3x+4y$.

