# isToric

This repo contains an implementation for the algorithm presented in .....
Everything is contained in the file isToric.sage, the other files are examples.

The purpose is to decide if a given variety can be made toric by a linear change of coordinates.

# Some documentation

LieAlgebra(I, *basis)

This is our main \texttt{class}. Let $G$ be the subgroup of $\GL_n(\C)$ that maps $I$ to itself. This class computes a basis of the Lie algebra of the Lie group $G$.
We can also construct it by giving it a generating set directly and instead of an ideal the parameter \texttt{None}. 
Note that the vector space generated by the given matrices has to generate a Lie algebra, i.e. being closed under taking commutators.

The main functions of this class are as follows.

\begin{verbatim}dimension()\end{verbatim}
Returns the dimension of the Lie algebra.

\begin{verbatim}basis()\end{verbatim}
Returns a basis of the Lie algebra.

\begin{verbatim}part_random_element()\end{verbatim}
Tries to pick a random linear combination of the basis elements with coefficients $\pm\frac{1}{2},\pm 1,\pm 2,0$ until this matrix has unique eigenvalues. If this does not happen after several attempts, a more random element is returned allowing more coefficients.


\begin{verbatim}cartan_algebra(A)\end{verbatim}
Computes $\c := \ker \ad(A)^{\dim \g}$. This is always a Lie subalgebra and is returned if it is a Cartan subalgebra of the Lie algebra. Otherwise the output is \texttt{False}.

\begin{verbatim}random_cartan_algebra()\end{verbatim}
Picks a random element in the Lie algebra and computes the corresponding Cartan algebra.

\begin{verbatim}find_torus()\end{verbatim}
Decomposes every basis element of the Lie algebra into its diagonalizable and nilpotent part and returns an element of class \texttt{LieAlgebra} generated by all diagonalizable elements.
This is only supposed to be used when \texttt{self} is a Cartan algebra. In this case the returned element is a toral Lie algebra corresponding to the unique maximal torus inside \texttt{self}.

\begin{verbatim}random_torus()\end{verbatim}
Computes a random Cartan algebra and inside it, its unique maximal toral subalgebra. This is a maximal toral subalgebra of \texttt{self}.

\begin{verbatim}sim_diagonalize()\end{verbatim}
Should only be used when \texttt{self} is a toral algebra. Computes a base change $S$ over the ring of algebraic numbers that simultaneously diagonalizes the basis of \texttt{self}.


Next, we provide functions to handle our ideal or to use when doing parts by hand.


\begin{verbatim}matrix_diagonalize(A)\end{verbatim}
Returns an invertible matrix $S$ over the field of algebraic numbers diagonalizing $A$, i.e. such that $S^{-1}AS$ is diagonal.

\begin{verbatim}ideal_diagonalize(I,S)\end{verbatim}
Applies the \cc given by the rows of $S$ to the ideal $I$.
Outputs the resulting ideal in the polynomial ring over the field of algebraic numbers.

\begin{verbatim}is_binomial(I)\end{verbatim}
Tests if the ideal $I$ can be generated by binomials (polynomials with at most two terms, we do not require the coefficients to be 0,1) and returns \texttt{True} or \texttt{False}. 
Also returns a reduced \gb of $I$.

\begin{verbatim}binomial_ideal_is_prime(gb)\end{verbatim}
Checks if the binomial ideal generated by the \gb given in \texttt{gb} is prime over $\C$.


\begin{verbatim}is_toric(generators) \end{verbatim}
Decides if the ideal $I$ generated by the polynomials in \texttt{generators} is toric after some \cc. If this is the case the output is \texttt{True} and a matrix $S\in\GL_n(\overline{\Q})$ is returned turning $I$ into a binomial ideal. Otherwise the output is \texttt{False}.

  Consider the ideal $I$ from \cref{ex:complete_intersection} generated by the three forms $p_1,p_2,p_3\in\C[q,w,e,r,t,y,u,o]_2$
  forming a complete intersection,
  \[
    p_1=e t - r y - q u + w o,\quad p_2=w t - q y - r u + e o,\quad p_3=w e - q r - y u + t o
  \]
  We present the code to find a \cc making this ideal binomial.
  
\begin{verbatim}
load('.../isToric.sage')
R.<q,w,e,r,t,y,u,o>=PolynomialRing(QQ)
p1=e*t-r*y-q*u+w*o
p2=w*t-q*y-r*u+e*o
p3=w*e-q*r-y*u+t*o
I=ideal(p1,p2,p3)

#Compute the Lie algebra and a random Cartan algebra of L.
lie=LieAlgebra(I)
c=lie.random_cartan_algebra()

#Compute the unique toral Lie algebra inside c.
t=c.find_torus()

#Diagonalizing a generic element in t gives a coordinate change 
#that simultaneously diagonalizes t.
S=t.sim_diagonalize()

#We apply our coordinate change to our starting ideal.
J=ideal_diagonalize(I,S)

#We check if after the coordinate change the ideal
#is binomial and prime.
[is_bin,gb]=is_binomial(J)
 -> is_bin = True
binomial_ideal_is_prime(gb)
 -> True
\end{verbatim}  

Or the short-hand version
\begin{verbatim}
ideal_is_toric(I)
\end{verbatim}

This returns \texttt{True} and the \cc given in \cref{ex:complete_intersection}.



For a non-homogenous ideal the workflow is exactly the same. We just note that the coordinate change we get is a $(n+1) \times (n+1)$-matrix where the first row and column correspond to the homogenizing variable. Moreover, by construction, the first row is the first unit vector. For example the inverse of the matrix 
\[
\begin{pmatrix}
1 & 0 & 0\\
1 & 2 & 3\\
2 & 3 & 4
\end{pmatrix}
\]
applied to a polynomial in $\C[x,y]$ corresponds to the variable substitution $x\mapsto 1+2x+3y,\, y\mapsto 2+3x+4y$.

